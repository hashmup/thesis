最適化の方法として,複数のパラメータからモデル,実行環境に即したパラメータを選択するという手法を選択したが,
そのためには複数のパラメータでシミュレーションを行いその結果を集約するプログラムが必要となる.\\
本研究ではこのパラメータ選択を容易かつ高速に行うため以下に示すプログラムを作成した.\\
・MODファイルからパラメータとなりうる変数を自動で抽出し,それぞれの関係性を元に配列とその順序の候補を生成する.\\
・ジョブキューのシステムを持っているマシンにおいて,複数のジョブを並行して投げ結果を非同期的に集約できる.\\
・実行結果を最適化前のデフォルトの結果と比較し,実行結果に対して影響がないかを確認する.\\
・json形式で実行するファイル,各パラメータの範囲（プロセス数は1から10など）を指定することができる.\\
\subsubsection{全体構成}
はじめにシミュレータプログラムを構成する要素について示す.\\
( TODO: 章番号)にあるアルゴリズムで述べたように,探索の対象となるパラメータは,モデルに依存するパラメータ,
実行マシンに依存するパラメータそしてコンパイルに関わるパラメータの3つに大別される.\\
そのうち,モデルとコンパイルに関わるパラメータは実行形式の生成に関与し,実行マシンに関わるパラメータは
ジョブスクリプトの生成に関わる.\\
\paragraph{単一ジョブの実行}
パラメータのシミュレーションを一度行う際のプログラムの動作を次に示す.\\
\begin{figure}[htb]
% h:here, t:top, b:bottom, p:page
  \begin{center}
    \includegraphics[width=10.0cm]{./images/singlejob}
    \caption{単一ジョブ実行時の挙動}
    \label{fig:singlejob}
  \end{center}
\end{figure}
\\
図( TODO: 番号)にあるようにジョブの実行はジョブの生成,ジョブの実行,ジョブ結果の集約の3段階に分かれており,
ジョブの生成にかかる時間そしてジョブが実行されるまでのジョブキューでの待機時間がこの一連の動作の実行時間において大きな割合を示す.\\
ジョブが実行されるまでの待機時間は複数のジョブを実行する場合ではジョブの実行時間と同義になるため,これはシミュレーションの内容に応じて変わるが,
ジョブの生成に関してはビルドするプログラムに大きな違いは現れず,多くの場合ジョブの生成時間 $<$ ジョブの実行時間という関係が成立する.\\

また,ジョブの生成部分について詳しく見ると,実行形式とジョブスクリプトそれぞれの生成にかかる時間は表 ( TODO: 表を作る)のようになり,
スーパーコンピュータ京,研究室クラスタ双方において実行形式の生成にかかる時間が多いことがわかる.\\

\paragraph{複数ジョブの並列実行}
次にシミュレータの詳細について複数のジョブの並列実行を例として示す.\\

単一ジョブの実行例からパラメータを選択するためにコード,コンパイル,ジョブそれぞれの候補から一つを選択するという3重のループを組む際に,
最も内側のループ内でジョブスクリプトの生成を行い,外側のループで生成した実行形式を使い回すことでシミュレーションをより高速に行うことができる.\\
また,スーパーコンピュータ京のように非常に多くのノードを持つマシンでない場合,ジョブの実行時間の方が長いため多数のジョブがジョブキューに溜まる状態になる.
そのため,外側のループで実行形式を生成する形を取ることで,ジョブの実行が溜まっているうちに実行形式のビルドを行うことができるようになり,結果として最初の一回を除き以降のビルドは
シミュレーションの実行時間に関与しなくすることができる.\\

本研究では以上を念頭に置きシミュレータのプログラムを作成した.\\
単一ジョブの実行 ( TODO: add ref)で述べたように,ジョブの実行をするにはジョブの生成,ジョブの実行,ジョブ結果の集約が必要となる.\\
その中でジョブの実行はqsubやpjsubといった環境にインストールされているジョブ実行環境を利用するため,シミュレータはジョブの生成と結果の集約の役割を担う.\\
\begin{figure}[htb]
% h:here, t:top, b:bottom, p:page
  \begin{center}
    \includegraphics[width=10.0cm]{./images/simulator.pdf}
    \caption{シミュレータ 構成}
    \label{fig:test}
  \end{center}
\end{figure}
\\
そのため,シミュレータは次の疑似コードで示す通りジョブを生成するためのループと
メインスレッドから切り離されたスレッドでジョブの実行状況を監視し,
ジョブが終了したタイミングで結果の集約を行うメソッドという二つの機能から成り立っている.\\
\\
\\
\\
\\
\\
\\
\\
\\
\\
{\footnotesize
\lstinputlisting[caption=シミュレータ疑似コード,label=pseudocode-simulator,frame=single]{src/pseudocode/simulator}
}
また疑似コードを状態遷移図の形で可視化したものが次になる.\\
\begin{figure}[htb]
% h:here, t:top, b:bottom, p:page
  \begin{center}
    \includegraphics[width=20.0cm]{./images/state.pdf}
    \caption{シミュレータ 状態遷移図}
    \label{fig:test}
  \end{center}
\end{figure}
\subparagraph{ジョブ生成ループ}~\\
疑似コード内の8-22行目までがジョブ生成のためのループを構成している.\\
{\footnotesize
\lstinputlisting[caption=シミュレータ 全体ループ,label=hogehoge,frame=single, firstline=8, lastline=22]{src/pseudocode/simulator}
}
ループ内部では,プログラムのビルド,ジョブスクリプトの生成,そして生成した実行形式とジョブスクリプトをジョブキューにdeployするという3つのことを行っている.\\
プログラムのビルド,ジョブの実行に比べジョブスクリプトの生成にかかる時間は無視できる程度のものであるため,ジョブスクリプトの生成をもっとも内側のループに持ってきた.\\
これにより,ジョブキューでジョブが実行されるのを待っているうちにビルドを行うことができ,全体としてシミュレーションの時間を減らすことが期待できる.\\
\subparagraph{ジョブ実行}~\\
{\footnotesize
\lstinputlisting[caption=シミュレータ ジョブ実行,label=hogehoge,frame=single, firstline=24, lastline=29]{src/pseudocode/simulator}
}
スーパーコンピュータ京のような複数のユーザーが用いるシステムにおいて,ジョブを一度に大量に投げるのは好ましくない.\\
そのため,ジョブをジョブキューに投げる前に事前に設定した最大同時ジョブ実行数と現在の実行中のジョブの数を比較し,最大数と同数なのであれば待機する処理が必要である.\\
本研究では,グローバル変数として現在実行中のジョブのIDを保持するリストを定義し,そのリストの数と比較することで実現している.\\
また,後述するジョブ結果の集約においてこのジョブIDを保持するリストは別スレッドから参照されており,リスト内のジョブが完了した段階でmutexによってロックされた上で更新される.\\
\paragraph{ジョブ結果の集約}~\\
{\footnotesize
\lstinputlisting[caption=シミュレータ ジョブ結果の集約,label=hogehoge,frame=single, firstline=31, lastline=37]{src/pseudocode/simulator}
}
様々なパラメータの組の中から最適な組み合わせを選びたいため,それぞれのジョブの結果とパラメータの組を結びつける必要がある.\\
ジョブが完了したか否かは,ジョブの状況を取得するコマンドを利用することで得ることができる.\\
次にスーパーコンピュータ京と研究室クラスタで上記のコマンドを実行した結果を示す.\\
{\footnotesize
\begin{lstlisting}[numbers=none]
京
>> pjstat
a


研究室クラスタ
>> qstat
Job ID  Name  User  Time  Use S Queue
--- --  ----  ----  ----  --- - -----
3381.cluster  job_cluster.sh  inoue 00:44:33  C cluster
3383.cluster  job_cluster.sh  inoue 00:23:59  C cluster
3384.cluster  job_cluster.sh  inoue 00:47:37  C cluster
3385.cluster  job_cluster.sh  inoue 00:24:02  C cluster
3386.cluster  job_cluster.sh  inoue 00:23:57  C cluster
3387.cluster  job_cluster.sh   inoue           00:47:32 C cluster
3388.cluster               job_cluster.sh   inoue           00:24:07 C cluster
3389.cluster               job_cluster.sh   inoue           00:24:01 C cluster
3390.cluster               job_cluster.sh   inoue           00:18:33 R cluster
3391.cluster               job_cluster.sh   inoue 0 R cluster
3392.cluster               job_cluster.sh   inoue                  0 Q cluster
3393.cluster               job_cluster.sh   inoue                  0 Q cluster




\end{lstlisting}
}
\subsubsection{モデルに依存するパラメータ}
